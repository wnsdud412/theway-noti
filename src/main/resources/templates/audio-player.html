<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon_32.png" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.4.1/font/bootstrap-icons.css" rel="stylesheet" />
  <title>조옮김 플레이어</title>
  <link th:href="@{/css/styles.css}" rel="stylesheet" />
  <!-- pwa meta-->
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#0d6efd">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="Theway-noti">
  <link rel="apple-touch-icon" href="/images/icon_192.png">
  <!-- 로그인 정보 -->
  <meta name="_csrf" th:content="${_csrf.token}" />
  <meta name="_csrf_header" th:content="${_csrf.headerName}" />
</head>

<body class="bg-light">
  <div class="container py-5">
    <div class="row justify-content-center">
      <div class="col-md-8 col-lg-6">
        
        <!-- 헤더 -->
        <div class="text-center mb-5">
          <h1 class="h3 mb-3">조옮김 음원 플레이어</h1>
        </div>

        <!-- URL 입력 폼 -->
        <div class="card shadow-sm mb-4">
          <div class="card-body">
            <form id="urlForm">
              <div class="mb-3">
                <label for="youtubeUrl" class="form-label">YouTube URL</label>
                <input type="text" 
                       class="form-control form-control-lg" 
                       id="youtubeUrl" 
                       placeholder="YouTube URL, 비디오 ID, 플레이리스트 URL 또는 플레이리스트 ID"
                       required>
                <div class="form-text">
                  YouTube URL, 비디오 ID (11자리) 또는 플레이리스트 ID를 입력하세요
                </div>
              </div>
              <button type="submit" class="btn btn-primary btn-lg w-100" id="loadBtn">
                <i class="bi bi-play-circle"></i> 음원 로드
              </button>
            </form>
          </div>
        </div>

        <!-- 상태 표시 -->
        <div id="statusCard" class="card shadow-sm mb-4" style="display: none;">
          <div class="card-body">
            <div class="d-flex align-items-center">
              <div class="spinner-border spinner-border-sm me-3" role="status" id="loadingSpinner">
                <span class="visually-hidden">Loading...</span>
              </div>
              <div>
                <div id="statusMessage" class="fw-bold">준비 중...</div>
                <div class="progress mt-2" style="height: 8px;">
                  <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                </div>
                <small id="progressText" class="text-muted">0%</small>
              </div>
            </div>
          </div>
        </div>

        <!-- 오디오 플레이어 -->
        <div id="playerCard" class="card shadow-sm mb-4" style="display: none;">
          <div class="card-body">
            <div class="text-center mb-3">
              <h5 id="audioTitle" class="card-title">🎵 오디오 재생 준비</h5>
              <small id="videoIdDisplay" class="text-muted"></small>
            </div>
            
            <audio id="audioPlayer" class="w-100" controls preload="metadata">
              <source id="audioSource" type="audio/mpeg">
              브라우저가 오디오 재생을 지원하지 않습니다.
            </audio>

            <!-- 조옮김 컨트롤 -->
            <div class="mt-4">
              <div class="row align-items-center">
                <div class="col-3">
                  <label for="pitchSlider" class="form-label fw-bold">조옮김</label>
                </div>
                <div class="col-6">
                  <input type="range" 
                         class="form-range" 
                         id="pitchSlider" 
                         min="-12" 
                         max="12" 
                         value="0" 
                         step="1">
                </div>
                <div class="col-3 text-end">
                  <span id="pitchValue" class="badge bg-primary fs-6">0</span>
                  <button class="btn btn-outline-secondary btn-sm ms-2" 
                          id="pitchResetBtn" 
                          onclick="resetPitch()">
                    <i class="bi bi-arrow-counterclockwise"></i>
                  </button>
                </div>
              </div>
              <div class="text-center mt-2">
                <small class="text-muted">-12 (한 옥타브 낮게) ~ +12 (한 옥타브 높게)</small>
              </div>
            </div>
            
          </div>
        </div>

        <!-- 에러 메시지 -->
        <div id="errorCard" class="alert alert-danger" role="alert" style="display: none;">
          <i class="bi bi-exclamation-triangle"></i>
          <span id="errorMessage">오류가 발생했습니다.</span>
        </div>

        <!-- 홈으로 돌아가기 -->
        <div class="text-center">
          <a href="/" class="btn btn-outline-secondary">
            <i class="bi bi-house"></i> 홈으로 돌아가기
          </a>
        </div>

      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
  <script>
    let pollInterval = null;
    let currentVideoId = null;
    let currentInputType = null; // 'video' 또는 'playlist'
    let currentPlaylistData = null; // 현재 로드된 플레이리스트 데이터
    
    // Tone.js 및 오디오 관련 변수들
    let audioContext = null;
    let pitchShift = null;
    let mediaSource = null;
    let isAudioSetup = false;
    let audioSetupAttempted = false;

    // YouTube URL에서 비디오 ID 추출
    function extractVideoId(input) {
      if (!input || input.trim() === '') return null;
      
      const trimmedInput = input.trim();
      
      // 이미 비디오 ID인 경우 (11자리 영숫자, -, _)
      if (/^[a-zA-Z0-9_-]{11}$/.test(trimmedInput)) {
        return trimmedInput;
      }
      
      // YouTube URL 패턴들
      const patterns = [
        /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})/,
        /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?.*v=([a-zA-Z0-9_-]{11})/,
        /(?:https?:\/\/)?(?:www\.)?youtu\.be\/([a-zA-Z0-9_-]{11})/,
        /(?:https?:\/\/)?(?:m\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})/,
        /(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([a-zA-Z0-9_-]{11})/,
        /(?:https?:\/\/)?music\.youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})/
      ];
      
      for (const pattern of patterns) {
        const match = trimmedInput.match(pattern);
        if (match) {
          return match[1];
        }
      }
      
      return null;
    }

    // YouTube URL에서 플레이리스트 ID 추출
    function extractPlaylistId(input) {
      if (!input || input.trim() === '') return null;
      
      const trimmedInput = input.trim();
      
      // 이미 플레이리스트 ID인 경우
      if (/^PL[a-zA-Z0-9_-]{32}$|^[a-zA-Z0-9_-]{34}$/.test(trimmedInput)) {
        return trimmedInput;
      }
      
      // YouTube 플레이리스트 URL 패턴들
      const patterns = [
        /[?&]list=([a-zA-Z0-9_-]+)/,  // 모든 URL에서 list= 파라미터
        /(?:https?:\/\/)?(?:www\.)?youtube\.com\/playlist\?list=([a-zA-Z0-9_-]+)/,
        /(?:https?:\/\/)?music\.youtube\.com\/playlist\?list=([a-zA-Z0-9_-]+)/
      ];
      
      for (const pattern of patterns) {
        const match = trimmedInput.match(pattern);
        if (match) {
          return match[1];
        }
      }
      
      return null;
    }

    // 입력값 파싱 - 비디오인지 플레이리스트인지 구분
    function parseYouTubeInput(input) {
      if (!input || input.trim() === '') return null;
      
      const trimmedInput = input.trim();
      
      // 1. 비디오 체크 (우선순위: 비디오가 있으면 비디오를 우선)
      const videoId = extractVideoId(trimmedInput);
      if (videoId) {
        return { type: 'video', id: videoId };
      }
      
      // 2. 플레이리스트 체크
      const playlistId = extractPlaylistId(trimmedInput);
      if (playlistId) {
        return { type: 'playlist', id: playlistId };
      }
      
      return null;
    }

    // 상태 확인 API 호출
    async function checkStatus(videoId) {
      try {
        const response = await fetch(`/transposition/download?videoId=${videoId}`);
        const data = await response.json();
        
        console.log('Status check result:', data);
        
        updateStatusDisplay(data);
        
        // 완료된 경우 플레이어 로드
        if (data.success && data.status === 'success' && data.audioFile) {
          clearInterval(pollInterval);
          loadAudioPlayer(videoId, data.audioFile);
        }
        // 진행중인 경우 계속 폴링
        else if (data.status === 'in_progress') {
          // 폴링 계속
        }
        // 실패한 경우 에러 표시
        else if (data.status === 'failure') {
          clearInterval(pollInterval);
          showError(data.message || '다운로드에 실패했습니다.');
        }
        
      } catch (error) {
        console.error('Status check error:', error);
        clearInterval(pollInterval);
        showError('상태 확인 중 오류가 발생했습니다.');
      }
    }

    // 상태 표시 업데이트
    function updateStatusDisplay(data) {
      const statusMessage = document.getElementById('statusMessage');
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      
      if (data.status === 'in_progress') {
        const progress = (data.progress || 0) * 100;
        statusMessage.textContent = data.message || '다운로드 중...';
        progressBar.style.width = `${progress}%`;
        progressText.textContent = `${progress.toFixed(1)}%`;
      } else if (data.status === 'success') {
        statusMessage.textContent = '다운로드 완료! 플레이어를 로드하는 중...';
        progressBar.style.width = '100%';
        progressText.textContent = '100%';
      }
    }

    // 완전히 새로운 오디오 요소 생성
    function createNewAudioElement(videoId) {
      const playerCard = document.getElementById('playerCard');
      const audioContainer = playerCard.querySelector('.card-body');
      
      // 기존 audio 요소 제거
      const oldAudio = document.getElementById('audioPlayer');
      if (oldAudio) {
        oldAudio.remove();
      }
      
      // 새 audio 요소 생성
      const newAudio = document.createElement('audio');
      newAudio.id = 'audioPlayer';
      newAudio.className = 'w-100';
      newAudio.controls = true;
      newAudio.preload = 'metadata';
      newAudio.crossOrigin = 'anonymous'; // CORS 지원을 위한 crossOrigin 설정
      
      const source = document.createElement('source');
      source.id = 'audioSource';
      source.type = 'audio/mpeg';
      source.src = `/transposition/stream/${videoId}`;
      
      newAudio.appendChild(source);
      newAudio.innerHTML += '브라우저가 오디오 재생을 지원하지 않습니다.';
      
      // 조옮김 컨트롤 앞에 삽입
      const pitchControl = audioContainer.querySelector('.mt-4');
      audioContainer.insertBefore(newAudio, pitchControl);
      
      // 이벤트 리스너 추가
      newAudio.addEventListener('play', setupAudioSystemOnPlay);
      newAudio.addEventListener('loadeddata', setupAudioSystemOnLoad);
      
      return newAudio;
    }

    // 오디오 로딩 대기 함수
    function waitForAudioReady(audioElement) {
      return new Promise((resolve) => {
        if (audioElement.readyState >= 2) { // HAVE_CURRENT_DATA 이상
          resolve();
        } else {
          const onLoadedData = () => {
            audioElement.removeEventListener('loadeddata', onLoadedData);
            resolve();
          };
          audioElement.addEventListener('loadeddata', onLoadedData);
        }
      });
    }

    // Tone.js 오디오 시스템 초기화
    async function setupAudioSystem() {
      if (isAudioSetup || audioSetupAttempted) return;
      audioSetupAttempted = true;
      
      try {
        // Tone.js context 시작
        await Tone.start();
        console.log('Tone.js context started');
        
        const audioPlayer = document.getElementById('audioPlayer');
        if (!audioPlayer) {
          console.error('Audio player not found');
          return;
        }
        
        // 오디오가 충분히 로드될 때까지 대기
        await waitForAudioReady(audioPlayer);
        console.log('Audio is ready, creating MediaElementSource...');
        
        // MediaElementAudioSourceNode 생성 (한 번만)
        mediaSource = Tone.context.createMediaElementSource(audioPlayer);
        
        // PitchShift 이펙트 생성 - 고품질 설정
        pitchShift = new Tone.PitchShift({
          pitch: 0,
          windowSize: 0.1,  
          overlap: 8,        
          delayTime: 0.1       
        });
        
        // Tone.js 노드 연결 - 안전한 방식
        // 중간 gain 노드를 통한 연결
        const gainNode = Tone.context.createGain();
        gainNode.gain.value = 1.0;
        
        // 연결 체인 구성
        mediaSource.connect(gainNode);
        
        // Tone.js PitchShift의 내부 구조에 맞는 연결
        try {
          // PitchShift 입력 노드 확인 및 연결
          const inputNode = pitchShift.input;
          if (inputNode._nativeAudioNode) {
            // Tone.js 내부 네이티브 노드에 연결
            gainNode.connect(inputNode._nativeAudioNode);
          } else if (inputNode.input) {
            // 중첩된 input 속성이 있는 경우
            gainNode.connect(inputNode.input);
          } else {
            // 직접 연결
            gainNode.connect(inputNode);
          }
          
          // PitchShift 출력을 destination에 연결
          pitchShift.toDestination();
          
          console.log('Audio chain: mediaSource -> gainNode -> pitchShift.input -> pitchShift -> destination');
          
        } catch (connectionError) {
          console.error('Connection failed, trying alternative approach:', connectionError);
          
          // 대안적 연결 방법
          gainNode.connect(Tone.getDestination().input);
          console.log('Fallback: direct connection to destination (no pitch shift)');
        }
        
        isAudioSetup = true;
        console.log('Audio system setup completed');
        
      } catch (error) {
        console.error('Audio system setup failed:', error);
        audioSetupAttempted = false;
        isAudioSetup = false;
      }
    }

    // 이벤트 핸들러 함수들
    async function setupAudioSystemOnPlay() {
      if (!isAudioSetup) {
        await setupAudioSystem();
        // 오디오 시스템 설정 후 현재 슬라이더 값으로 조옮김 적용
        const currentPitch = parseInt(document.getElementById('pitchSlider').value);
        if (currentPitch !== 0) {
          setTimeout(() => changePitch(currentPitch), 100);
        }
      }
    }

    async function setupAudioSystemOnLoad() {
      if (!isAudioSetup) {
        await setupAudioSystem();
        // 오디오 시스템 설정 후 현재 슬라이더 값으로 조옮김 적용
        const currentPitch = parseInt(document.getElementById('pitchSlider').value);
        if (currentPitch !== 0) {
          setTimeout(() => changePitch(currentPitch), 100);
        }
      }
    }

    // 오디오 플레이어 로드
    function loadAudioPlayer(videoId, audioFile) {
      const audioTitle = document.getElementById('audioTitle');
      const videoIdDisplay = document.getElementById('videoIdDisplay');
      
      // 오디오 시스템 리셋
      isAudioSetup = false;
      audioSetupAttempted = false;
      
      if (mediaSource) {
        try {
          mediaSource.disconnect();
        } catch (e) {}
        mediaSource = null;
      }
      
      if (pitchShift) {
        try {
          pitchShift.dispose();
        } catch (e) {}
        pitchShift = null;
      }
      
      // 새로운 audio 요소 생성
      createNewAudioElement(videoId);
      
      // UI 업데이트 - audioFile의 title 사용
      const title = audioFile && audioFile.title ? audioFile.title : (videoId || '오디오 재생');
      audioTitle.textContent = '🎵 ' + title;
      videoIdDisplay.textContent = `Video ID: ${videoId}`;
      
      // 카드 표시/숨김
      hideStatus();
      showPlayer();
      
      console.log('Audio player loaded for:', videoId, 'title:', title);
    }

    // 플레이리스트 요청 처리
    async function handlePlaylistRequest(playlistId) {
      try {
        console.log('Handling playlist request for:', playlistId);
        
        const response = await fetch(`/transposition/playlist/${playlistId}`);
        const data = await response.json();
        
        console.log('Playlist request result:', data);
        
        if (data.success) {
          currentPlaylistData = data;
          showPlaylistInfo(data);
        } else {
          showError(data.message || '플레이리스트를 불러오는데 실패했습니다.');
        }
        
      } catch (error) {
        console.error('Playlist request error:', error);
        showError('플레이리스트 요청 중 오류가 발생했습니다.');
      }
    }

    // 플레이리스트 정보 표시
    function showPlaylistInfo(playlistData) {
      hideStatus();
      hidePlayer();
      hideError();
      
      // 플레이리스트 정보 카드가 없으면 생성
      let playlistCard = document.getElementById('playlistCard');
      if (!playlistCard) {
        playlistCard = createPlaylistCard();
      }
      
      // 플레이리스트 정보 업데이트
      const playlistTitle = document.getElementById('playlistTitle');
      const playlistVideoCount = document.getElementById('playlistVideoCount');
      const playlistVideosList = document.getElementById('playlistVideosList');
      
      playlistTitle.textContent = playlistData.title;
      playlistVideoCount.textContent = `${playlistData.videoCount}개 비디오`;
      
      // 비디오 목록 생성
      playlistVideosList.innerHTML = '';
      playlistData.videos.forEach((video, index) => {
        const videoItem = createVideoListItem(video, index);
        playlistVideosList.appendChild(videoItem);
      });
      
      // 플레이리스트 카드 표시
      playlistCard.style.display = 'block';
    }

    // 플레이리스트 카드 생성
    function createPlaylistCard() {
      const container = document.querySelector('.col-md-8.col-lg-6');
      const playlistCard = document.createElement('div');
      playlistCard.id = 'playlistCard';
      playlistCard.className = 'card shadow-sm mb-4';
      playlistCard.style.display = 'none';
      
      playlistCard.innerHTML = `
        <div class="card-body">
          <div class="text-center mb-3">
            <h5 id="playlistTitle" class="card-title">🎵 플레이리스트</h5>
            <small id="playlistVideoCount" class="text-muted">0개 비디오</small>
          </div>
          <div class="mb-3">
            <h6>비디오 목록:</h6>
            <div id="playlistVideosList" class="playlist-videos" style="max-height: 400px; overflow-y: auto;">
              <!-- 비디오 목록이 여기에 추가됩니다 -->
            </div>
          </div>
          <div class="text-center">
            <button class="btn btn-outline-secondary" onclick="resetPlayer()">
              <i class="bi bi-arrow-left"></i> 다른 URL 입력
            </button>
          </div>
        </div>
      `;
      
      // 에러 카드 앞에 삽입
      const errorCard = document.getElementById('errorCard');
      container.insertBefore(playlistCard, errorCard);
      
      return playlistCard;
    }

    // 비디오 목록 아이템 생성
    function createVideoListItem(video, index) {
      const item = document.createElement('div');
      item.className = 'border-bottom pb-2 mb-2';
      
      const duration = video.duration 
        ? `${Math.floor(video.duration / 60)}:${String(video.duration % 60).padStart(2, '0')}`
        : '';
      
      item.innerHTML = `
        <div class="d-flex justify-content-between align-items-center">
          <div class="flex-grow-1">
            <div class="fw-bold small">${video.title}</div>
            <div class="text-muted small">
              ID: ${video.videoId}
              ${duration ? `・ ${duration}` : ''}
            </div>
          </div>
          <button class="btn btn-primary btn-sm" onclick="loadVideoFromPlaylist('${video.videoId}', '${video.title.replace(/'/g, "\\'")}')">
            <i class="bi bi-play-circle"></i> 재생
          </button>
        </div>
      `;
      
      return item;
    }

    // 플레이리스트에서 비디오 로드
    async function loadVideoFromPlaylist(videoId, title) {
      console.log('Loading video from playlist:', videoId, title);
      
      currentVideoId = videoId;
      currentInputType = 'video';
      
      // 플레이리스트 숨기고 상태 표시
      document.getElementById('playlistCard').style.display = 'none';
      showStatus();
      
      try {
        // 기존 비디오 로드 로직 사용
        await checkStatus(videoId);
        
        // 2초마다 상태 확인 (완료될 때까지)
        pollInterval = setInterval(() => {
          checkStatus(videoId);
        }, 2000);
        
      } catch (error) {
        console.error('Load error:', error);
        showError('요청 처리 중 오류가 발생했습니다.');
      }
    }

    // UI 표시/숨김 함수들
    function showStatus() {
      document.getElementById('statusCard').style.display = 'block';
      document.getElementById('loadingSpinner').style.display = 'block';
    }

    function hideStatus() {
      document.getElementById('statusCard').style.display = 'none';
    }

    function showPlayer() {
      document.getElementById('playerCard').style.display = 'block';
    }

    function hidePlayer() {
      document.getElementById('playerCard').style.display = 'none';
    }

    function hidePlaylist() {
      const playlistCard = document.getElementById('playlistCard');
      if (playlistCard) {
        playlistCard.style.display = 'none';
      }
    }

    function showError(message) {
      document.getElementById('errorMessage').textContent = message;
      document.getElementById('errorCard').style.display = 'block';
      hideStatus();
      hidePlayer();
    }

    function hideError() {
      document.getElementById('errorCard').style.display = 'none';
    }


    // 오디오 체인 재구성 함수
    function reconfigureAudioChain(usePitchShift) {
      if (!isAudioSetup || !gainNode || !mediaSource) return;
      
      try {
        // 기존 연결 해제
        gainNode.disconnect();
        
        if (usePitchShift) {
          // PitchShift 사용: mediaSource -> gainNode -> pitchShift -> destination
          const inputNode = pitchShift.input;
          if (inputNode._nativeAudioNode) {
            gainNode.connect(inputNode._nativeAudioNode);
          } else if (inputNode.input) {
            gainNode.connect(inputNode.input);
          } else {
            gainNode.connect(inputNode);
          }
          console.log('Audio chain: mediaSource -> gainNode -> pitchShift -> destination');
        } else {
          // 바이패스 모드: mediaSource -> gainNode -> destination
          gainNode.connect(Tone.getDestination().input);
          console.log('Audio chain: mediaSource -> gainNode -> destination (bypass)');
        }
        
        isBypassed = !usePitchShift;
      } catch (error) {
        console.error('Failed to reconfigure audio chain:', error);
      }
    }

    // 조옮김 값 변경 함수
    function changePitch(semitones) {
      if (pitchShift && isAudioSetup) {
        // 반음 단위 직접 설정 (Tone.js PitchShift는 semitone 단위를 사용)
        pitchShift.pitch = semitones;
        
        // UI 업데이트
        document.getElementById('pitchValue').textContent = semitones > 0 ? `+${semitones}` : semitones;
        
        console.log(`Pitch changed to ${semitones} semitones`);
      } else if (!isAudioSetup) {
        console.warn('Audio system not setup yet. Pitch change will be applied when audio starts.');
        // UI만 업데이트
        document.getElementById('pitchValue').textContent = semitones > 0 ? `+${semitones}` : semitones;
      }
    }

    // 조옮김 리셋 함수
    function resetPitch() {
      const pitchSlider = document.getElementById('pitchSlider');
      pitchSlider.value = 0;
      changePitch(0);
    }

    // 플레이어 리셋
    function resetPlayer() {
      clearInterval(pollInterval);
      currentVideoId = null;
      currentInputType = null;
      currentPlaylistData = null;
      
      document.getElementById('youtubeUrl').value = '';
      hideStatus();
      hidePlayer();
      hidePlaylist();
      hideError();
      
      const audioPlayer = document.getElementById('audioPlayer');
      if (audioPlayer) {
        audioPlayer.pause();
        audioPlayer.src = '';
      }
      
      // 조옮김도 리셋
      resetPitch();
      
      // 오디오 시스템 정리 및 리셋
      if (mediaSource) {
        try {
          mediaSource.disconnect();
        } catch (e) {
          // 무시
        }
        mediaSource = null;
      }
      
      if (pitchShift) {
        try {
          pitchShift.dispose();
        } catch (e) {
          // 무시
        }
        pitchShift = null;
      }
      
      isAudioSetup = false;
      audioSetupAttempted = false;
    }

    // 폼 제출 처리
    document.getElementById('urlForm').addEventListener('submit', async function(e) {
      e.preventDefault();
      
      const input = document.getElementById('youtubeUrl').value.trim();
      const parsedInput = parseYouTubeInput(input);
      
      if (!parsedInput) {
        showError('유효한 YouTube URL, 비디오 ID, 플레이리스트 URL 또는 플레이리스트 ID를 입력해주세요.');
        return;
      }
      
      // 입력 타입에 따라 분기 처리
      currentInputType = parsedInput.type;
      
      // UI 초기화
      hideError();
      hidePlayer();
      hidePlaylist(); // 플레이리스트 카드도 숨김
      
      // 버튼 상태 변경
      const loadBtn = document.getElementById('loadBtn');
      loadBtn.disabled = true;
      const originalButtonText = loadBtn.innerHTML;
      loadBtn.innerHTML = '<i class="bi bi-arrow-repeat"></i> 로드 중...';
      
      try {
        if (parsedInput.type === 'video') {
          // 비디오 처리
          currentVideoId = parsedInput.id;
          showStatus();
          
          // 즉시 상태 확인
          await checkStatus(parsedInput.id);
          
          // 2초마다 상태 확인 (완료될 때까지)
          pollInterval = setInterval(() => {
            checkStatus(parsedInput.id);
          }, 2000);
          
        } else if (parsedInput.type === 'playlist') {
          // 플레이리스트 처리
          await handlePlaylistRequest(parsedInput.id);
        }
        
      } catch (error) {
        console.error('Load error:', error);
        showError('요청 처리 중 오류가 발생했습니다.');
      } finally {
        // 버튼 복구
        setTimeout(() => {
          loadBtn.disabled = false;
          loadBtn.innerHTML = originalButtonText;
        }, 1000);
      }
    });

    // 조옮김 슬라이더 이벤트 리스너
    document.getElementById('pitchSlider').addEventListener('input', function(e) {
      const semitones = parseInt(e.target.value);
      changePitch(semitones);
    });

    // 오디오 플레이어 이벤트 리스너는 createNewAudioElement에서 동적으로 추가됨

    // 페이지 언로드 시 정리
    window.addEventListener('beforeunload', function() {
      clearInterval(pollInterval);
    });
  </script>

</body>
</html>